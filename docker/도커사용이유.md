# why container?

### 1. Docker 

처음 python으로 만들어졌음

> The future of Linux Container Pycon2013



### 2. 기존의 서버 운영

>  컨테이너가 등장하기 이전

어플리케이션이 동작하는 **상태**를 유지하는 작업



#### 서버운영에 필요한것

* 프로비저닝
  * 어플리케이션이 동작하는 **상태**를 만드는 방법
* 배포
  * 프로비저닝된 서버에서 어플리케이션을 실행
* 서버 운영
  * 배포된 어플리케이션이 동작 가능한 **상태**를 유지



즉, 프로비저닝 ~ 배포 ~ 서버운영 (거의 한몸처럼 움직인다.)



#### 서버 운영이 어려운 이유

* 서버 A, B, C 간의 환경이 전부다름 (A에서는 되는데 B에서는 안되고...)
* 불투명한 의존성 관리 (의존성이 충돌함)
* 모든 app의 요구 조건을 만족해야만 함
* 명렁어는 절차적이고, 휘발적이고, 재현 불가능



#### 서버운영을 좀 더 잘하기 위한 발전

* Cloud
  * 클라우드의 등장, 하드웨어 가상화 (기존의 문제점인 하드웨어 파면화 해결)
  * 사용한 만큼만 비용을 청구
  * 이미지화 & 스케일 인/아웃
  * 오토스케일링
  * 이미지를 기반으로한 다수의 서버 상태 관리
    * 상태 관리에 대한 새로운 접근
    * 서버 운영의 문제는 여전히 그대로 남아있다!
* lac
  * Configuration Management
    * 서버 운영의 추상화
      * 명령어를 통한 서버 관리를 지양
      * 상태를 관리하는 코드를 작성하고 서버에 적용
      * 선언적 서버 상태 정의
      * 서버의 상태가 재현 가능해짐(불완전)
      * 서버 운영의 협업이 가능해짐
* Plaform as a Service



#### Dyno

LXC(Chroot on steroid) : 서버에서 app을 실행 시키는건 똑같지만 컨테이너 환경을 실행시키는 것



#### 12factor

https://12factor.net/ko/



#### Docker의 등장

배포 / 프로비저닝 / 서버운영



### 서버 운영의 미래

Immutable Infrastructure

* 프로비저닝은 이미지 생성 시점에 완료
* 배포는 프로비저닝과 별도로 원하는 시점에
* 서버는 컨테이너를 실행시키기 위한 환경일 뿐
  * 컨테이너 실행을 위한 최소한 환경만을 구성
  * 서버의 상태를 적극적으로 관리하지 않음
* 서버 없이 컨테이너를 실행하는 서비스의 등작
  * 서버 운영의 종말





## 컨테이너의 이해

Docker의 등장 배경과 서버 운영의 미래

